{"version":3,"file":"index.mjs","sources":["../src/separable-blend.ts","../src/separable-modes.ts","../src/helpers.ts","../src/non-separable-blend.ts","../src/non-separable-modes.ts","../src/index.ts"],"sourcesContent":["import { ChannelBlender, RGB, RGBA } from './types'\n\n/**\n * Blend two colors in a separable way (i.e. each color channel individually)\n *\n * @param backdrop The RGBA backdrop color\n * @param source   The RGBA source color\n * @param callback The blend mode callback to apply\n */\nexport default function separableBlend(\n  backdrop: RGBA,\n  source: RGBA,\n  callback: ChannelBlender\n): RGB {\n  return {\n    r: callback(backdrop.r / 255, source.r / 255) * 255,\n    g: callback(backdrop.g / 255, source.g / 255) * 255,\n    b: callback(backdrop.b / 255, source.b / 255) * 255\n  }\n}\n","/**\n * Algorithms for separable blend modes (i.e. where the same algorithms is applied to each color channel)\n * @see https://www.w3.org/TR/compositing-1/#blendingseparable\n */\n\n/**\n * Blend two color channels with the \"normal\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\n// @ts-ignore the unused first parameter to comply with the interface\nexport function normal(backdrop: number, source: number) {\n  return source\n}\n\n/**\n * Blend two color channels with the \"multiply\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function multiply(backdrop: number, source: number) {\n  return backdrop * source\n}\n\n/**\n * Blend two color channels with the \"screen\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function screen(backdrop: number, source: number) {\n  return backdrop + source - backdrop * source\n}\n\n/**\n * Blend two color channels with the \"overlay\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function overlay(backdrop: number, source: number) {\n  return hardLight(source, backdrop)\n}\n\n/**\n * Blend two color channels with the \"darken\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function darken(backdrop: number, source: number) {\n  return Math.min(backdrop, source)\n}\n\n/**\n * Blend two color channels with the \"lighten\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function lighten(backdrop: number, source: number) {\n  return Math.min(Math.max(backdrop, source), 1)\n}\n\n/**\n * Blend two color channels with the \"color dodge\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function colorDodge(backdrop: number, source: number) {\n  return backdrop === 0\n    ? 0\n    : source === 1\n    ? 1\n    : Math.min(1, backdrop / (1 - source))\n}\n\n/**\n * Blend two color channels with the \"color burn\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function colorBurn(backdrop: number, source: number) {\n  return backdrop === 1\n    ? 1\n    : source === 0\n    ? 0\n    : 1 - Math.min(1, (1 - backdrop) / source)\n}\n\n/**\n * Blend two color channels with the \"hard light\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function hardLight(backdrop: number, source: number) {\n  return source <= 0.5\n    ? multiply(backdrop, 2 * source)\n    : screen(backdrop, 2 * source - 1)\n}\n\n/**\n * Blend two color channels with the \"soft light\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function softLight(backdrop: number, source: number) {\n  return source <= 0.5\n    ? backdrop - (1 - 2 * source) * backdrop * (1 - backdrop)\n    : backdrop +\n        (2 * source - 1) *\n          ((backdrop <= 0.25\n            ? ((16 * backdrop - 12) * backdrop + 4) * backdrop\n            : Math.sqrt(backdrop)) -\n            backdrop)\n}\n\n/**\n * Blend two color channels with the \"difference\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function difference(backdrop: number, source: number) {\n  return Math.abs(backdrop - source)\n}\n\n/**\n * Blend two color channels with the \"exclusion\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function exclusion(backdrop: number, source: number) {\n  return backdrop + source - 2 * backdrop * source\n}\n","import { ChannelBlender, NoAlphaBlender, RGB, RGBA } from './types'\n\n// Some utility (no actual blend-related algorithms) for color handling\n\n/**\n * Restricts a number to given boundaries\n * @param value The number to restrict\n * @param from  The lower boundary\n * @param to    The upper boundary\n * @return The restricted value\n */\nfunction restrictNumber(value: number, from: number, to: number) {\n  return Math.min(Math.max(value, from), to)\n}\n\n/**\n * Restricts an { r,g,b,a } color to its boundaries (0..255 color channels, 0..1 alpha channel)\n * @param color The { r,g,b,a } color to restrict\n * @return The restricted color\n */\nfunction restrictColor(color: RGBA): RGBA {\n  return {\n    r: restrictNumber(color.r, 0, 255),\n    g: restrictNumber(color.g, 0, 255),\n    b: restrictNumber(color.b, 0, 255),\n    a: restrictNumber(color.a, 0, 1)\n  }\n}\n\n/**\n * Converts a color from unit color channels [0..1] to 8-bit color channels [0..255]\n * @param color The { r,g,b,a } color to convert\n * @return The { r,g,b,a } with 8-bit color channels\n */\nexport function convertFromUnit(color: RGBA): RGBA\nexport function convertFromUnit(color: RGB): RGB\nexport function convertFromUnit(color: any): RGB | RGBA {\n  return {\n    r: color.r * 255,\n    g: color.g * 255,\n    b: color.b * 255,\n    a: color.a\n  }\n}\n\n/**\n * Converts a color from 8-bit color channels [0..255] to unit color channels [0..1]\n * @param color The { r,g,b,a } color to convert\n * @return The { r,g,b,a } with unit color channels\n */\nexport function convertToUnit(color: RGBA): RGBA\nexport function convertToUnit(color: RGB): RGB\nexport function convertToUnit(color: any): RGB | RGBA {\n  return {\n    r: color.r / 255,\n    g: color.g / 255,\n    b: color.b / 255,\n    a: color.a\n  }\n}\n\n/**\n * Rounds the color channels of an RGBA color\n * @param color     The { r,g,b,a } color to handle\n * @param precision How many decimals? Defaults to 0\n * @return The { r,g,b,a } with rounded color channels\n */\nfunction roundChannels(color: RGBA, precision?: number): RGBA\nfunction roundChannels(color: RGB, precision?: number): RGB\nfunction roundChannels(color: any, precision: number = 0): RGB | RGBA {\n  const multiplier = Math.pow(10, precision)\n\n  return {\n    r: Math.round(color.r * multiplier) / multiplier,\n    g: Math.round(color.g * multiplier) / multiplier,\n    b: Math.round(color.b * multiplier) / multiplier,\n    a: color.a\n  }\n}\n\n/**\n * Rounds the color channels of an RGBA color with high precision to aviod IEEE 754 related issues\n * @param color The { r,g,b,a } color to handle\n * @return The { r,g,b,a } with rounded color channels\n */\nfunction roundChannelsBinaryFloat(color: RGBA): RGBA {\n  return roundChannels(color, 9)\n}\n\n/**\n * Applies the appropriate alpha blending to a blend process.\n * @see https://www.w3.org/TR/compositing-1/#blending\n * @param backdropAlpha  The alpha channel of the backdrop color [0..1]\n * @param sourceAlpha    The alpha channel of the source color [0..1]\n * @param compositeAlpha The alpha channel of the composite color [0..1]\n * @param backdropColor  A color channel (R, G or B) of the backdrop color [0..255]\n * @param sourceColor    A color channel (R, G or B) of the source color [0..255]\n * @param compositeColor A color channel (R, G or B) of the composite color [0..255]\n * @return The resulting color channel\n */\nfunction alphaCompose(\n  backdropAlpha: number,\n  sourceAlpha: number,\n  compositeAlpha: number,\n  backdropColor: number,\n  sourceColor: number,\n  compositeColor: number\n) {\n  return (\n    (1 - sourceAlpha / compositeAlpha) * backdropColor +\n    (sourceAlpha / compositeAlpha) *\n      Math.round(\n        (1 - backdropAlpha) * sourceColor + backdropAlpha * compositeColor\n      )\n  )\n}\n\nexport interface BlendOptions {\n  unitInput: boolean\n  unitOutput: boolean\n  roundOutput: boolean\n}\n\n/**\n * Blend two colors\n * All RGBA objects are { r,g,b,a } with [0..255] for RGB and [0..1] for alpha\n * @param source               The { r,g,b,a } color to be put on top\n * @param backdrop             The { r,g,b,a } color to be put below the source\n * @param abstractModeCallback The abstract blend mode function (separable vs. non-separable)\n * @param concreteModeCallback The concrete blend mode function (normal, multiply, ...)\n * @param options              The options to apply\n * @return The { r,g,b,a } result object, channel values are not rounded\n */\nexport function performBlend(\n  backdrop: RGBA,\n  source: RGBA,\n  abstractModeCallback: (\n    backdrop: RGBA,\n    source: RGBA,\n    concreteModeCallback: ChannelBlender\n  ) => RGB,\n  concreteModeCallback: ChannelBlender,\n  options?: Partial<BlendOptions>\n): RGBA\nexport function performBlend(\n  backdrop: RGBA,\n  source: RGBA,\n  abstractModeCallback: (\n    backdrop: RGBA,\n    source: RGBA,\n    concreteModeCallback: NoAlphaBlender\n  ) => RGB,\n  concreteModeCallback: NoAlphaBlender,\n  options?: Partial<BlendOptions>\n): RGBA\nexport function performBlend(\n  backdrop: RGBA,\n  source: RGBA,\n  abstractModeCallback: (\n    backdrop: RGBA,\n    source: RGBA,\n    concreteModeCallback: any\n  ) => RGB,\n  concreteModeCallback: ChannelBlender | NoAlphaBlender,\n  options: Partial<BlendOptions> = {\n    unitInput: false,\n    unitOutput: false,\n    roundOutput: true\n  }\n) {\n  // Handle unit input if needed\n  if (options.unitInput) {\n    backdrop = convertFromUnit(backdrop)\n    source = convertFromUnit(source)\n  }\n\n  // Remove out-of-bounds values\n  backdrop = restrictColor(backdrop)\n  source = restrictColor(source)\n\n  // Calculate resulting alpha\n  const a = source.a + backdrop.a - source.a * backdrop.a\n\n  // Calculate resulting RGB\n  const resultRGB = abstractModeCallback(backdrop, source, concreteModeCallback)\n\n  // Calculate actual RGBs from backdrop, source and result + alpha values\n  // Since blending may result in out-of-bounds color channels, cut those\n  let resultRGBA = restrictColor({\n    r: alphaCompose(backdrop.a, source.a, a, backdrop.r, source.r, resultRGB.r),\n    g: alphaCompose(backdrop.a, source.a, a, backdrop.g, source.g, resultRGB.g),\n    b: alphaCompose(backdrop.a, source.a, a, backdrop.b, source.b, resultRGB.b),\n    a: a\n  })\n\n  // Convert color channels to unit values if needed\n  if (options.unitOutput) {\n    resultRGBA = convertToUnit(resultRGBA)\n\n    // Round 8-bit color channels if needed\n  } else if (options.roundOutput) {\n    resultRGBA = roundChannels(resultRGBA)\n\n    // Round anyways to get rid of JavaScript floating point issues\n  } else {\n    resultRGBA = roundChannelsBinaryFloat(resultRGBA)\n  }\n\n  return resultRGBA\n}\n","import { convertFromUnit, convertToUnit } from './helpers'\nimport { NoAlphaBlender, RGBA } from './types'\n\n/**\n * Blend two colors in a non-separable way\n *\n * @param backdrop The background color as an { r,g,b,a } object\n * @param source   The foreground color as an { r,g,b,a } object\n * @param callback The blend mode callback to apply\n */\nexport default function nonSeparableBlend(\n  backdrop: RGBA,\n  source: RGBA,\n  callback: NoAlphaBlender\n) {\n  return convertFromUnit(\n    callback(convertToUnit(backdrop), convertToUnit(source))\n  )\n}\n","/**\n * Algorithms for non-separable blend modes (based on HSV/HSL color space)\n * @see https://www.w3.org/TR/compositing-1/#blendingnonseparable\n */\n\nimport { RGB } from './types'\n\n/**\n * Get the luminosity of a color\n *\n * @param rgb The color as an { r,g,b } object with each channel as a fraction\n */\nfunction getLuminosity(rgb: RGB) {\n  return 0.3 * rgb.r + 0.59 * rgb.g + 0.11 * rgb.b\n}\n\n/**\n * Clip the channels of a color\n *\n * @param rgb The color as an { r,g,b } object with each channel as a fraction\n */\nfunction clipColor(rgb: RGB): RGB {\n  const luminosity = getLuminosity(rgb)\n  let { r, g, b } = rgb\n\n  const lowestChannel = Math.min(r, g, b)\n  const highestChannel = Math.max(r, g, b)\n\n  function clipLowest(channel: number) {\n    return (\n      luminosity +\n      ((channel - luminosity) * luminosity) / (luminosity - lowestChannel)\n    )\n  }\n\n  function clipHighest(channel: number) {\n    return (\n      luminosity +\n      ((channel - luminosity) * (1 - luminosity)) /\n        (highestChannel - luminosity)\n    )\n  }\n\n  if (lowestChannel < 0) {\n    r = clipLowest(r)\n    g = clipLowest(g)\n    b = clipLowest(b)\n  }\n\n  if (highestChannel > 1) {\n    r = clipHighest(r)\n    g = clipHighest(g)\n    b = clipHighest(b)\n  }\n\n  return { r, g, b }\n}\n\n/**\n * Set luminosity on a color\n *\n * @param rgb        The color as an { r,g,b } object with each channel as a fraction\n * @param luminosity The luminosity to apply\n */\nfunction setLuminosity(rgb: RGB, luminosity: number) {\n  const delta = luminosity - getLuminosity(rgb)\n\n  return clipColor({\n    r: rgb.r + delta,\n    g: rgb.g + delta,\n    b: rgb.b + delta\n  })\n}\n\n/**\n * Get the saturation of a color\n *\n * @param rgb The color as an { r,g,b } object with each channel as a fraction\n */\nfunction getSaturation(rgb: RGB) {\n  return Math.max(rgb.r, rgb.g, rgb.b) - Math.min(rgb.r, rgb.g, rgb.b)\n}\n\n/**\n * Set saturation on a color\n *\n * @param rgb        The color as an { r,g,b } object with each channel as a fraction\n * @param saturation The saturation to apply\n */\nfunction setSaturation(rgb: RGB, saturation: number) {\n  const sortedChannels = ['r', 'g', 'b'].sort(\n    (a, b) => rgb[a as keyof RGB] - rgb[b as keyof RGB]\n  ) as [keyof RGB, keyof RGB, keyof RGB]\n  const channelMin = sortedChannels[0]\n  const channelMid = sortedChannels[1]\n  const channelMax = sortedChannels[2]\n\n  const result = {\n    r: rgb.r,\n    g: rgb.g,\n    b: rgb.b\n  }\n\n  if (result[channelMax] > result[channelMin]) {\n    result[channelMid] =\n      ((result[channelMid] - result[channelMin]) * saturation) /\n      (result[channelMax] - result[channelMin])\n    result[channelMax] = saturation\n  } else {\n    result[channelMid] = result[channelMax] = 0\n  }\n\n  result[channelMin] = 0\n\n  return result\n}\n\n/**\n * Blend two colors with the \"hue\" blend mode\n *\n * @param backdrop The background color channel as an { r,g,b } object with each channel represented as a fraction\n * @param source   The foreground color channel as an { r,g,b } object with each channel represented as a fraction\n * @return The blended color\n */\nexport function hue(backdrop: RGB, source: RGB) {\n  return setLuminosity(\n    setSaturation(source, getSaturation(backdrop)),\n    getLuminosity(backdrop)\n  )\n}\n\n/**\n * Blend two colors with the \"saturation\" blend mode\n *\n * @param backdrop The background color channel as an { r,g,b } object with each channel represented as a fraction\n * @param source   The foreground color channel as an { r,g,b } object with each channel represented as a fraction\n * @return The blended color\n */\nexport function saturation(backdrop: RGB, source: RGB) {\n  return setLuminosity(\n    setSaturation(backdrop, getSaturation(source)),\n    getLuminosity(backdrop)\n  )\n}\n\n/**\n * Blend two colors with the \"color\" blend mode\n *\n * @param backdrop The background color channel as an { r,g,b } object with each channel represented as a fraction\n * @param source   The foreground color channel as an { r,g,b } object with each channel represented as a fraction\n * @return The blended color\n */\nexport function color(backdrop: RGB, source: RGB) {\n  return setLuminosity(source, getLuminosity(backdrop))\n}\n\n/**\n * Blend two colors with the \"luminosity\" blend mode\n *\n * @param backdrop The background color channel as an { r,g,b } object with each channel represented as a fraction\n * @param source   The foreground color channel as an { r,g,b } object with each channel represented as a fraction\n * @return The blended color\n */\nexport function luminosity(backdrop: RGB, source: RGB) {\n  return setLuminosity(backdrop, getLuminosity(source))\n}\n","import separableBlend from './separable-blend'\nimport * as separableBlendModes from './separable-modes'\n\nimport nonSeparableBlend from './non-separable-blend'\nimport * as nonSeparableBlendModes from './non-separable-modes'\n\nimport { performBlend } from './helpers'\nimport { RGBA } from './types'\n\n/**\n * Blend two colors with the \"normal\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function normal(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.normal\n  )\n}\n\n/**\n * Blend two colors with the \"multiply\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function multiply(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.multiply\n  )\n}\n\n/**\n * Blend two colors with the \"screen\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function screen(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.screen\n  )\n}\n\n/**\n * Blend two colors with the \"overlay\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function overlay(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.overlay\n  )\n}\n\n/**\n * Blend two colors with the \"darken\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function darken(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.darken\n  )\n}\n\n/**\n * Blend two colors with the \"lighten\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function lighten(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.lighten\n  )\n}\n\n/**\n * Blend two colors with the \"color dodge\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function colorDodge(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.colorDodge\n  )\n}\n\n/**\n * Blend two colors with the \"color burn\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function colorBurn(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.colorBurn\n  )\n}\n\n/**\n * Blend two colors with the \"hard light\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function hardLight(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.hardLight\n  )\n}\n\n/**\n * Blend two colors with the \"soft light\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function softLight(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.softLight\n  )\n}\n\n/**\n * Blend two colors with the \"difference\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function difference(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.difference\n  )\n}\n\n/**\n * Blend two colors with the \"exclusion\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function exclusion(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.exclusion\n  )\n}\n\n/**\n * Blend two colors with the \"hue\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function hue(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    nonSeparableBlend,\n    nonSeparableBlendModes.hue\n  )\n}\n\n/**\n * Blend two colors with the \"saturation\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function saturation(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    nonSeparableBlend,\n    nonSeparableBlendModes.saturation\n  )\n}\n\n/**\n * Blend two colors with the \"color\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function color(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    nonSeparableBlend,\n    nonSeparableBlendModes.color\n  )\n}\n\n/**\n * Blend two colors with the \"luminosity\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function luminosity(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    nonSeparableBlend,\n    nonSeparableBlendModes.luminosity\n  )\n}\n"],"names":["separableBlend","backdrop","source","callback","r","g","b","normal","multiply","screen","overlay","hardLight","darken","Math","min","lighten","max","colorDodge","colorBurn","softLight","sqrt","difference","abs","exclusion","restrictNumber","value","from","to","restrictColor","color","a","convertFromUnit","convertToUnit","roundChannels","precision","multiplier","pow","round","alphaCompose","backdropAlpha","sourceAlpha","compositeAlpha","backdropColor","sourceColor","compositeColor","performBlend","abstractModeCallback","concreteModeCallback","options","unitInput","unitOutput","roundOutput","resultRGB","resultRGBA","nonSeparableBlend","getLuminosity","rgb","setLuminosity","luminosity","delta","lowestChannel","highestChannel","clipLowest","channel","clipHighest","clipColor","getSaturation","setSaturation","saturation","sortedChannels","sort","channelMin","channelMid","channelMax","result","hue","separableBlendModes","nonSeparableBlendModes"],"mappings":"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"}